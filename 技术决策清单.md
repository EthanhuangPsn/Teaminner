# 开发前技术决策清单

本文档基于《软件需求说明》整理，提供技术选型建议和关键决策点。

## 一、核心技术栈决策

### 1.1 前端技术栈

| 决策项 | 选项 | 推荐方案 | 理由 |
|--------|------|----------|------|
| **前端框架** | React / Vue / Angular / 原生JS | **React + TypeScript** | 1. 生态成熟，组件库丰富（Ant Design、Material-UI）<br>2. TypeScript提供类型安全，适合复杂状态管理<br>3. 社区活跃，商业化项目广泛使用<br>4. 便于后续扩展和维护 |
| **状态管理** | Redux / Zustand / MobX / Context API | **Zustand** | 1. 轻量级，学习曲线平缓<br>2. 适合实时状态同步场景<br>3. 与WebSocket集成简单<br>4. 性能优秀，代码简洁 |
| **UI组件库** | Ant Design / Material-UI / Chakra UI | **Ant Design** | 1. 中文文档完善，适合国内团队<br>2. 组件丰富，开箱即用<br>3. 支持主题定制<br>4. 商业化项目验证充分 |
| **WebRTC库** | 原生WebRTC API / simple-peer / mediasoup-client | **原生WebRTC API + 封装** | 1. 直接使用浏览器原生API，性能最优<br>2. 完全控制，便于实现复杂路由逻辑<br>3. 配合mediasoup服务端使用<br>4. 避免第三方库的兼容性问题 |
| **音频处理** | Web Audio API / WebAssembly / 第三方库 | **Web Audio API + WebAssembly（可选）** | 1. Web Audio API浏览器原生支持，性能好<br>2. 对于复杂算法（降噪、回声消除），可考虑WASM<br>3. 初期使用Web Audio API，后期优化时引入WASM |
| **实时通信** | WebSocket / Socket.io / SockJS | **原生WebSocket + 封装** | 1. 轻量级，无额外依赖<br>2. 完全控制消息格式<br>3. 性能最优<br>4. 配合JSON或Protocol Buffers使用 |

**推荐技术栈组合**：
```
React 18+ + TypeScript
+ Zustand (状态管理)
+ Ant Design (UI组件)
+ 原生WebRTC API (音频通信)
+ 原生WebSocket (实时通信)
+ Vite (构建工具)
```

### 1.2 后端技术栈

| 决策项 | 选项 | 推荐方案 | 理由 |
|--------|------|----------|------|
| **后端语言** | Node.js / Go / Java / Python | **Node.js (TypeScript)** | 1. 与前端技术栈统一，团队技能复用<br>2. 异步I/O适合实时通信场景<br>3. WebRTC生态成熟（mediasoup）<br>4. 开发效率高，快速迭代<br>5. 适合中小型团队快速开发 |
| **Web框架** | Express / Koa / Fastify / NestJS | **NestJS** | 1. 基于TypeScript，类型安全<br>2. 模块化架构，便于维护<br>3. 内置WebSocket支持<br>4. 适合中大型项目，便于扩展<br>5. 依赖注入，测试友好 |
| **SFU服务器** | mediasoup / Kurento / Janus / 自研 | **mediasoup** | 1. 专为WebRTC设计，性能优秀<br>2. Node.js生态，与后端技术栈统一<br>3. 支持动态路由，完美契合需求<br>4. 文档完善，社区活跃<br>5. 商业化项目验证充分 |
| **实时通信** | Socket.io / ws / uWebSockets.js | **ws (原生WebSocket)** | 1. 轻量级，性能优秀<br>2. 与前端WebSocket统一<br>3. 完全控制，无额外开销<br>4. 适合高并发场景 |
| **ORM/数据库** | Prisma / TypeORM / Sequelize / Mongoose | **Prisma** | 1. TypeScript原生支持，类型安全<br>2. 迁移管理完善<br>3. 开发体验优秀<br>4. 支持PostgreSQL/MySQL |

**推荐技术栈组合**：
```
Node.js 18+ (TypeScript)
+ NestJS (Web框架)
+ mediasoup (SFU服务器)
+ ws (WebSocket)
+ Prisma (ORM)
+ PostgreSQL (数据库)
```

### 1.3 数据库选型

| 决策项 | 选项 | 推荐方案 | 理由 |
|--------|------|----------|------|
| **主数据库** | PostgreSQL / MySQL / MongoDB | **PostgreSQL** | 1. 支持JSON类型，适合存储灵活配置<br>2. 事务支持完善，数据一致性保障<br>3. 性能优秀，适合高并发<br>4. 扩展性强，支持复杂查询<br>5. 开源免费，商业化友好 |
| **缓存数据库** | Redis / Memcached | **Redis** | 1. 存储房间状态、用户会话<br>2. 支持发布订阅，可用于状态同步<br>3. 支持过期时间，适合游客会话管理<br>4. 性能优秀，支持高并发 |

**推荐数据库组合**：
```
PostgreSQL (主数据库)
+ Redis (缓存/会话存储)
```

### 1.4 认证与安全

| 决策项 | 选项 | 推荐方案 | 理由 |
|--------|------|----------|------|
| **认证方式** | JWT / Session / OAuth | **JWT (访问令牌) + Refresh Token** | 1. 无状态，适合分布式部署<br>2. 前端存储方便<br>3. Refresh Token机制保障安全<br>4. 支持游客临时令牌 |
| **密码加密** | bcrypt / argon2 | **bcrypt** | 1. 成熟稳定，广泛使用<br>2. 安全性足够<br>3. 实现简单 |
| **HTTPS/WSS** | 必须 | **必须启用** | 1. WebRTC要求HTTPS（生产环境）<br>2. 保护用户数据安全<br>3. 防止中间人攻击 |

## 二、架构设计决策

### 2.1 系统架构

**推荐架构：微服务架构（初期可单体，后期拆分）**

```
┌─────────────────────────────────────────────────────────┐
│                     客户端 (浏览器)                        │
│  React + WebRTC + WebSocket                              │
└──────────────┬──────────────────────────────────────────┘
               │
               │ HTTPS/WSS
               │
┌──────────────▼──────────────────────────────────────────┐
│                    API Gateway                           │
│              (NestJS + 负载均衡)                          │
└──────────────┬──────────────────────────────────────────┘
               │
       ┌───────┴────────┐
       │                │
┌──────▼─────┐   ┌──────▼─────┐
│  业务服务   │   │  SFU服务    │
│  (NestJS)  │   │ (mediasoup) │
│            │   │             │
│ - 用户管理  │   │ - 音频路由   │
│ - 房间管理  │   │ - 音频转发   │
│ - 编队管理  │   │ - 音频处理   │
│ - 状态同步  │   │             │
└──────┬─────┘   └──────┬─────┘
       │                │
       └───────┬────────┘
               │
       ┌───────▼────────┐
       │   数据库层      │
       │ PostgreSQL     │
       │ + Redis        │
       └────────────────┘
```

**架构说明**：
1. **初期**：业务服务和SFU服务可部署在同一进程，简化部署
2. **后期**：根据负载情况，将SFU服务独立部署，支持水平扩展
3. **API Gateway**：统一入口，处理认证、限流、路由

### 2.2 音频路由实现方案

**推荐方案：mediasoup + 自定义路由逻辑**

```typescript
// 伪代码示例
class AudioRouter {
  // 根据房间状态和用户身份计算路由表
  calculateRoutes(room: Room): Route[] {
    const routes: Route[] = [];
    
    if (room.status === 'preparing') {
      // 备战：全房间广播
      return this.createFullRoomRoutes(room);
    } else {
      // 攻坚：根据身份和编队计算
      return this.createAssaultRoutes(room);
    }
  }
  
  // 攻坚模式路由计算
  createAssaultRoutes(room: Room): Route[] {
    // 实现路由关系表的逻辑
    // 团长 ↔ 所有队长
    // 队长 ↔ 队长
    // 队长 ↔ 同队队员
    // 队员 ↔ 同队队员
  }
}
```

**mediasoup优势**：
- 支持动态添加/移除Producer和Consumer
- 可以根据路由表实时控制音频流
- 性能优秀，延迟低

## 三、关键业务决策

### 3.1 用户系统

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **游客昵称生成** | `游客${随机4位数字}`，允许用户修改 | 1. 简单直观<br>2. 用户可自定义，提升体验<br>3. 修改后实时同步到所有客户端 |
| **游客头像** | 随机预设头像（8-12个），允许用户选择 | 1. 无需上传，降低服务器负担<br>2. 统一风格，UI美观<br>3. 未来支持QQ登录时使用QQ头像 |
| **游客会话过期** | 24小时（从最后活动时间计算） | 1. 平衡用户体验和服务器资源<br>2. 过期后自动创建新会话<br>3. 存储在Redis，设置过期时间 |
| **昵称/头像修改** | 房间内可修改，实时同步 | 1. 提升用户体验<br>2. 通过WebSocket事件实时推送<br>3. 修改后所有客户端立即更新 |

### 3.2 房间系统

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **房间默认状态** | 备战（preparing） | 1. 新用户进入即可使用语音<br>2. 团长可随时切换到攻坚状态<br>3. 符合"休闲状态"的定位 |
| **房间创建** | 管理员创建，需设置：名称、描述（可选） | 1. 简化初期实现<br>2. 未来可扩展密码房间、私密房间<br>3. 房间列表显示名称和在线人数 |
| **房间列表排序** | 按在线人数降序，人数相同按创建时间 | 1. 热门房间优先显示<br>2. 便于用户选择活跃房间 |
| **房间列表刷新** | WebSocket实时推送 + 客户端定时刷新（30秒） | 1. 实时性保障<br>2. 定时刷新作为兜底机制 |
| **"开启房间语音服务"** | 用户首次进入房间时，浏览器请求麦克风权限 | 1. 明确用户意图<br>2. 如果拒绝权限，允许以只收听模式进入<br>3. 开启麦克风权限后，如果房间无团长，自动成为团长 |

### 3.3 编队系统

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **蓝紫小队启用** | 团长可启用，当红黄绿小队满员时提示 | 1. 灵活性高，按需启用<br>2. 避免资源浪费<br>3. UI上显示"未启用"状态，点击启用 |
| **小队删除/禁用** | 不支持删除，支持禁用（禁用后成员需重新编队） | 1. 简化实现<br>2. 禁用功能用于特殊情况处理<br>3. 禁用时提示成员重新编队 |
| **退出小队** | 提供"退出小队"按钮，退出后立即回到未编队状态 | 1. 操作明确，用户体验好<br>2. 退出后立即更新音频路由 |
| **小队满员处理** | 团长指定时：提示满员，需先调整编队<br>用户自行加入时：提示满员，建议选择其他小队 | 1. 团长有调整权限<br>2. 用户自行操作时友好提示 |
| **加入小队审批** | 无需审批，直接加入 | 1. 简化流程，提升效率<br>2. 符合游戏场景的快速组队需求 |

### 3.4 权限系统

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **房间管理员权限** | 1. 可指定/转让团长<br>2. 可踢出用户<br>3. 可修改房间状态（与团长权限相同）<br>4. 可启用/禁用蓝紫小队 | 1. 管理员拥有最高权限<br>2. 可在多个房间同时拥有管理员身份<br>3. 用于系统管理和异常处理 |
| **团长权限** | 1. 可转让团长<br>2. 可指定/转让队长<br>3. 可切换房间状态<br>4. 可指定用户编队<br>5. 可踢出用户（可选） | 1. 房间内的最高权限<br>2. 负责房间管理和指挥协调 |
| **踢出用户** | 支持，需提示理由（可选），被踢出用户可立即重新加入 | 1. 用于处理恶意用户<br>2. 理由可选，简化操作<br>3. 不设置黑名单，允许重新加入 |
| **禁言功能** | 暂不实现（MVP阶段） | 1. 简化初期实现<br>2. 可通过踢出功能替代<br>3. 未来版本可考虑添加 |

### 3.5 状态管理

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **用户离开房间** | 身份和编队状态不保留，退出后立即清除 | 1. 简化实现<br>2. 重新加入时重新分配<br>3. 如果退出时是团长，自动指定新团长 |
| **房间状态持久化** | 仅持久化房间基本信息，状态和编队信息不持久化 | 1. 房间状态和编队是运行时数据<br>2. 服务器重启后，房间状态重置为"备战"<br>3. 所有用户需重新编队 |
| **房间空置处理** | 所有用户离开后，房间状态重置，但房间保留 | 1. 房间作为资源保留<br>2. 下次使用时重新初始化 |

## 四、API设计决策

### 4.1 通信协议

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **HTTP API** | RESTful API + JSON | 1. 标准规范，易于理解<br>2. JSON格式，便于调试<br>3. 用于用户认证、房间列表等非实时操作 |
| **实时通信** | WebSocket + JSON | 1. 双向通信，实时性好<br>2. JSON格式，便于开发调试<br>3. 未来可升级为Protocol Buffers提升性能 |
| **音频流** | WebRTC (DTLS/SRTP) | 1. 标准协议，浏览器原生支持<br>2. 加密传输，安全性高<br>3. 低延迟，适合实时语音 |

### 4.2 API端点设计（核心接口）

**用户认证**
- `POST /api/auth/register` - 注册
- `POST /api/auth/login` - 登录
- `POST /api/auth/guest` - 游客登录
- `POST /api/auth/logout` - 登出
- `POST /api/auth/refresh` - 刷新令牌

**房间管理**
- `GET /api/rooms` - 获取房间列表
- `GET /api/rooms/:id` - 获取房间详情
- `POST /api/rooms/:id/join` - 加入房间
- `POST /api/rooms/:id/leave` - 离开房间
- `POST /api/rooms` - 创建房间（管理员）
- `DELETE /api/rooms/:id` - 删除房间（管理员）

**编队管理**
- `POST /api/rooms/:id/teams/:teamId/join` - 加入小队
- `POST /api/rooms/:id/teams/:teamId/leave` - 退出小队
- `POST /api/rooms/:id/teams/:teamId/assign` - 指定用户编队（团长）

**身份管理**
- `POST /api/rooms/:id/leader/transfer` - 转让团长
- `POST /api/rooms/:id/teams/:teamId/captain/assign` - 指定队长（团长）
- `POST /api/rooms/:id/teams/:teamId/captain/transfer` - 转让队长

**状态管理**
- `POST /api/rooms/:id/status` - 切换房间状态（团长）
- `GET /api/rooms/:id/status` - 获取房间状态

### 4.3 WebSocket事件设计

**客户端 → 服务端**
- `user:join-room` - 加入房间
- `user:leave-room` - 离开房间
- `user:update-audio` - 更新音频设置（麦克风/扬声器）
- `team:join` - 加入小队
- `team:leave` - 退出小队
- `role:transfer-leader` - 转让团长
- `role:transfer-captain` - 转让队长
- `room:change-status` - 切换房间状态

**服务端 → 客户端**
- `room:user-joined` - 用户加入
- `room:user-left` - 用户离开
- `room:team-changed` - 编队变更
- `room:role-changed` - 身份变更
- `room:status-changed` - 房间状态变更
- `room:audio-routes-updated` - 音频路由更新
- `user:speaking` - 用户发言状态
- `network:quality` - 网络质量变化

## 五、部署与运维决策

### 5.1 部署方案

| 决策项 | 推荐方案 | 说明 |
|--------|----------|------|
| **容器化** | Docker + Docker Compose（开发/测试） | 1. 环境一致性<br>2. 便于本地开发<br>3. 生产环境可使用Kubernetes |
| **反向代理** | Nginx | 1. 负载均衡<br>2. SSL终止<br>3. 静态资源服务 |
| **进程管理** | PM2（Node.js） | 1. 进程守护<br>2. 日志管理<br>3. 集群模式支持 |
| **监控** | Prometheus + Grafana | 1. 性能监控<br>2. 资源使用监控<br>3. 告警机制 |

### 5.2 性能指标目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **音频延迟** | < 200ms | 端到端延迟，包括网络传输和处理 |
| **房间并发** | 单服务器支持100+房间 | 根据服务器配置调整 |
| **单房间用户数** | 20人（需求规定） | 可配置，未来可扩展 |
| **客户端CPU** | < 30% | 音频处理优化 |
| **客户端内存** | < 200MB | 合理的内存使用 |
| **客户端带宽** | 上行 50-100kbps/人<br>下行 50-100kbps/人 | 根据音频质量调整 |

## 六、开发阶段规划

### 阶段一：MVP（最小可行产品）- 4-6周
**目标**：实现核心功能，验证可行性

**功能范围**：
- ✅ 用户注册/登录/游客登录
- ✅ 房间列表和加入房间
- ✅ 基础语音通信（备战模式）
- ✅ 编队系统（红黄绿三个小队）
- ✅ 基础UI（房间列表、房间页面）

**技术重点**：
- 搭建项目框架
- 实现基础WebRTC通信
- 实现房间和编队管理
- 基础音频路由

### 阶段二：核心功能完善 - 4-6周
**目标**：实现完整的业务逻辑

**功能范围**：
- ✅ 攻坚模式音频路由
- ✅ 身份系统（团长、队长）
- ✅ 房间状态切换
- ✅ 音频质量保障（降噪、回声消除等）
- ✅ UI完善（用户列表、状态提示）

**技术重点**：
- 实现复杂的音频路由逻辑
- 音频处理算法集成
- 状态同步优化
- UI/UX优化

### 阶段三：优化与扩展 - 持续
**目标**：性能优化、功能扩展、商业化准备

**功能范围**：
- ✅ 断线重连优化
- ✅ 网络质量自适应
- ✅ 蓝紫小队支持
- ✅ 管理员功能完善
- ✅ 性能优化
- ✅ 监控和日志系统

## 七、推荐技术栈总结

### 前端
```
React 18+ + TypeScript
+ Vite (构建工具)
+ Zustand (状态管理)
+ Ant Design (UI组件库)
+ 原生WebRTC API
+ 原生WebSocket
```

### 后端
```
Node.js 18+ + TypeScript
+ NestJS (Web框架)
+ mediasoup (SFU服务器)
+ ws (WebSocket库)
+ Prisma (ORM)
+ PostgreSQL (主数据库)
+ Redis (缓存/会话)
```

### 部署
```
Docker + Docker Compose
+ Nginx (反向代理)
+ PM2 (进程管理)
+ Prometheus + Grafana (监控)
```

### 开发工具
```
ESLint + Prettier (代码规范)
+ Jest (单元测试)
+ Playwright (E2E测试)
+ Git + GitHub/GitLab (版本控制)
```

## 八、风险评估与应对

| 风险 | 影响 | 应对方案 |
|------|------|----------|
| **WebRTC兼容性** | 高 | 1. 使用polyfill库<br>2. 提供浏览器兼容性检测<br>3. 明确支持的浏览器版本 |
| **音频延迟过高** | 高 | 1. 使用SFU架构降低延迟<br>2. 优化音频编解码参数<br>3. 使用边缘节点部署 |
| **服务器负载** | 中 | 1. 实现负载均衡<br>2. SFU服务独立部署<br>3. 监控和自动扩容 |
| **状态同步问题** | 中 | 1. 服务端权威模式<br>2. 版本号机制<br>3. 定期状态同步 |
| **浏览器权限** | 低 | 1. 友好的权限请求提示<br>2. 支持只收听模式<br>3. 权限被拒绝时的引导 |

## 九、下一步行动

1. **确认技术栈**：团队评审推荐方案，确认技术选型
2. **搭建项目框架**：初始化前后端项目，配置开发环境
3. **数据库设计**：根据数据结构设计数据库表结构
4. **API设计文档**：详细设计所有API接口
5. **开发环境搭建**：Docker环境、CI/CD流程
6. **开始MVP开发**：按照阶段一规划开始开发

---

**文档版本**：v1.0  
**创建日期**：2024年  
**最后更新**：2024年
